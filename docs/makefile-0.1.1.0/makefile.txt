-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple Makefile parser
--   
--   This package provides a few <tt>Attoparser</tt> parsers and
--   convenience functions for parsing Makefiles. The datatypes used for
--   describing Makefiles are located in <a>Data.Makefile</a>. The parsers
--   and parsing functions are located in <a>Data.Makefile.Parse</a>. To
--   parse a Makefile in the current folder, simply run
--   <a>parseMakefile</a>. To parse a Makefile located at <tt>path</tt>,
--   run <a>parseAsMakefile</a> <tt>path</tt>.
@package makefile
@version 0.1.1.0


-- | This module defines the different types used when working with a
--   Makefile.
--   
--   <pre>
--   # File: Makefile
--   
--   hello = world
--   
--   foo: bar
--     baz
--   </pre>
--   
--   <pre>
--   Makefile {
--     entries =
--       [ Assignment "hello " " world"
--       , Rule (Target "foo") [Dependency "bar"] [Command "baz"] ]
--       })
--   </pre>
module Data.Makefile

-- | A Makefile object, a list of makefile entries
data Makefile
Makefile :: [Entry] -> Makefile
[entries] :: Makefile -> [Entry]

-- | A makefile entry, either a rule <tt>(target: dep1 dep1; commands)</tt>
--   or a variable assignment (<tt>hello = world</tt> or <tt>hello :=
--   world</tt>)
data Entry
Rule :: Target -> [Dependency] -> [Command] -> Entry
Assignment :: AssignmentType -> Text -> Text -> Entry
data AssignmentType

-- | foo = bar
RecursiveAssign :: AssignmentType

-- | foo := bar
SimpleAssign :: AssignmentType

-- | foo ::= bar
SimplePosixAssign :: AssignmentType

-- | foo ?= bar
ConditionalAssign :: AssignmentType

-- | foo != bar
ShellAssign :: AssignmentType

-- | foo += bar
AppendAssign :: AssignmentType

-- | Makefile target (<tt>foo</tt> in the example above)
newtype Target
Target :: Text -> Target

-- | Target dependency (<tt>bar</tt> in the example above)
newtype Dependency
Dependency :: Text -> Dependency

-- | Command (<tt>baz</tt> in the example above)
newtype Command
Command :: Text -> Command
instance GHC.Classes.Eq Data.Makefile.Makefile
instance GHC.Show.Show Data.Makefile.Makefile
instance GHC.Classes.Eq Data.Makefile.Entry
instance GHC.Show.Show Data.Makefile.Entry
instance Data.String.IsString Data.Makefile.Command
instance GHC.Classes.Eq Data.Makefile.Command
instance GHC.Show.Show Data.Makefile.Command
instance Data.String.IsString Data.Makefile.Dependency
instance GHC.Classes.Eq Data.Makefile.Dependency
instance GHC.Show.Show Data.Makefile.Dependency
instance Data.String.IsString Data.Makefile.Target
instance GHC.Classes.Eq Data.Makefile.Target
instance GHC.Show.Show Data.Makefile.Target
instance GHC.Classes.Eq Data.Makefile.AssignmentType
instance GHC.Show.Show Data.Makefile.AssignmentType

module Data.Makefile.Parse.Internal

-- | Parse makefile.
--   
--   Tries to open and parse a file name <tt>Makefile</tt> in the current
--   directory.
parseMakefile :: IO (Either String Makefile)

-- | Parse the specified file as a makefile.
parseAsMakefile :: FilePath -> IO (Either String Makefile)
parseMakefileContents :: Text -> Either String Makefile

-- | Parser for a makefile
makefile :: Parser Makefile

-- | Parser for a makefile entry (either a rule or a variable assignment)
entry :: Parser Entry

-- | Parser of variable assignment (see <a>Assignment</a>). Note that
--   leading and trailing whitespaces will be stripped both from the
--   variable name and assigned value.
--   
--   Note that this tries to follow GNU make's (crazy) behavior when it
--   comes to variable names and assignment operators.
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo = bar "
--   Right (Assignment RecursiveAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo := bar "
--   Right (Assignment SimpleAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo ::= bar "
--   Right (Assignment SimplePosixAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo?= bar "
--   Right (Assignment ConditionalAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo??= bar "
--   Right (Assignment ConditionalAssign "foo?" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo!?!= bar "
--   Right (Assignment ShellAssign "foo!?" "bar")
--   </pre>
assignment :: Parser Entry

-- | Read chars while some (<a>Parser</a>, monadic) predicate is
--   <a>True</a>.
--   
--   XXX: extremely inefficient.
takeWhileM :: (Char -> Parser Bool) -> Parser Text
variableName :: Parser Text
assignmentType :: Parser AssignmentType

-- | Parser for an entire rule
rule :: Parser Entry

-- | Parser for a command
command :: Parser Command

-- | Parser for a (rule) target
target :: Parser Target

-- | Parser for a (rule) dependency
dependency :: Parser Dependency

-- | Parser for variable name in declaration (lazy set, <tt>var = x</tt>)
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly lazyVar "CFLAGS=-c -Wall"
--   Right "CFLAGS"
--   </pre>
lazyVar :: Parser Text

-- | Parser for variable name in declaration (immediate set, <tt>var :=
--   x</tt>)
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly immVar "CFLAGS:=-c -Wall"
--   Right "CFLAGS"
--   </pre>
immVar :: Parser Text

-- | Parser for a comment (the comment starts with the hashtag)
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly comment "# I AM A COMMENT"
--   Right " I AM A COMMENT"
--   </pre>
comment :: Parser Text

-- | Consume a newline character (<tt>'\n'</tt>)
nextLine :: Parser ()

-- | Consume an empty line (potentially containing spaces and/or tabs).
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly emptyLine "\t\t   \t   \t\n"
--   Right ()
--   </pre>
emptyLine :: Parser ()
toLineEnd :: Parser Text

-- | Get the contents until the end of the (potentially multi) line.
--   Multiple lines are separated by a <tt>\</tt> char and individual lines
--   will be stripped and spaces will be interspersed.
--   
--   The final <tt>n</tt> character is consumed.
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly toEscapedLineEnd "foo bar \\\n baz"
--   Right "foo bar baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly toEscapedLineEnd "foo \t\\\n bar \\\n baz \\\n \t"
--   Right "foo bar baz"
--   </pre>
toEscapedLineEnd :: Parser Text
stripped :: Parser Text -> Parser Text

module Data.Makefile.Parse

-- | Parse makefile.
--   
--   Tries to open and parse a file name <tt>Makefile</tt> in the current
--   directory.
parseMakefile :: IO (Either String Makefile)

-- | Parse the specified file as a makefile.
parseAsMakefile :: FilePath -> IO (Either String Makefile)
parseMakefileContents :: Text -> Either String Makefile

-- | Parser for a makefile
makefile :: Parser Makefile

-- | Parser for a makefile entry (either a rule or a variable assignment)
entry :: Parser Entry

-- | Parser of variable assignment (see <a>Assignment</a>). Note that
--   leading and trailing whitespaces will be stripped both from the
--   variable name and assigned value.
--   
--   Note that this tries to follow GNU make's (crazy) behavior when it
--   comes to variable names and assignment operators.
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo = bar "
--   Right (Assignment RecursiveAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo := bar "
--   Right (Assignment SimpleAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo ::= bar "
--   Right (Assignment SimplePosixAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo?= bar "
--   Right (Assignment ConditionalAssign "foo" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo??= bar "
--   Right (Assignment ConditionalAssign "foo?" "bar")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly assignment "foo!?!= bar "
--   Right (Assignment ShellAssign "foo!?" "bar")
--   </pre>
assignment :: Parser Entry

-- | Parser for an entire rule
rule :: Parser Entry

-- | Parser for a command
command :: Parser Command

-- | Parser for a (rule) target
target :: Parser Target

-- | Parser for a (rule) dependency
dependency :: Parser Dependency

-- | Parser for variable name in declaration (lazy set, <tt>var = x</tt>)
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly lazyVar "CFLAGS=-c -Wall"
--   Right "CFLAGS"
--   </pre>
lazyVar :: Parser Text

-- | Parser for variable name in declaration (immediate set, <tt>var :=
--   x</tt>)
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly immVar "CFLAGS:=-c -Wall"
--   Right "CFLAGS"
--   </pre>
immVar :: Parser Text

-- | Parser for a comment (the comment starts with the hashtag)
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly comment "# I AM A COMMENT"
--   Right " I AM A COMMENT"
--   </pre>
comment :: Parser Text

module Data.Makefile.Render.Internal
writeMakefile :: FilePath -> Makefile -> IO ()
encodeMakefile :: Makefile -> Text
renderMakefile :: Makefile -> Builder
renderEntry :: Entry -> Builder
renderDep :: Dependency -> Builder
renderCmd :: Command -> Builder

module Data.Makefile.Render
encodeMakefile :: Makefile -> Text
writeMakefile :: FilePath -> Makefile -> IO ()
